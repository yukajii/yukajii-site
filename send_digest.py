#!/usr/bin/env python3
"""
send_digest.py <digest_markdown_file>

Sends a markdown digest generated by **mt_arxiv_digest.py** to Buttondown.

Flow
----
1. Read the markdown file passed on the command‑line.
2. Create a draft e‑mail in Buttondown.  If Buttondown replies
   `email_duplicate`, look up the existing draft and re‑use its `id`.
3. Call `/send‑draft` to deliver the message to *all* active subscribers.
   If the draft was already sent earlier, exit 0 so CI remains green.

Environment
-----------
* **BUTTONDOWN_TOKEN** – API token from your Buttondown account.

Exit status is non‑zero only on unexpected HTTP failures so your GitHub
Actions job will mark a true error.
"""
from __future__ import annotations

import json
import os
import pathlib
import sys
import time
import urllib.parse
from datetime import datetime, timezone
from typing import Any, Dict

import requests

BTN_API = "https://api.buttondown.email/v1"
TIMEOUT = 30  # seconds for all HTTP calls


def bail(msg: str) -> None:
    """Print *msg* in red and terminate with exit 1."""
    print(f"\033[91m{msg}\033[0m", file=sys.stderr)
    sys.exit(1)


# ---------------------------------------------------------------------------
# 0⃣  CLI + env‑var checks
# ---------------------------------------------------------------------------
if len(sys.argv) != 2:
    bail("Usage: python send_digest.py mt_digest_YYYY-MM-DD.md")

md_path = pathlib.Path(sys.argv[1]).resolve()
if not md_path.exists():
    bail(f"File not found: {md_path}")

TOKEN = os.getenv("BUTTONDOWN_TOKEN")
if not TOKEN:
    bail("Env var BUTTONDOWN_TOKEN is missing")

subject_date = md_path.stem[-10:]  # YYYY-MM-DD at end of filename
try:
    pretty_date = datetime.strptime(subject_date, "%Y-%m-%d").strftime("%b %d %Y")
except ValueError:
    pretty_date = subject_date  # fallback, but should never happen

subject = f"Machine-Translation Digest — {pretty_date}"

headers: Dict[str, str] = {
    "Authorization": f"Token {TOKEN}",
    "Content-Type": "application/json",
}

# ---------------------------------------------------------------------------
# 1⃣  Create draft (or reuse existing duplicate)
# ---------------------------------------------------------------------------
print("⏳ Uploading draft…")

payload: Dict[str, Any] = {
    "subject": subject,
    "body": md_path.read_text(encoding="utf-8"),
    "markdown": True,
    "publish_url": False,
}

resp = requests.post(f"{BTN_API}/emails", headers=headers, data=json.dumps(payload), timeout=TIMEOUT)

if resp.ok:
    email_id = resp.json()["id"]
    print("✓ Draft created:", email_id)
else:
    err = resp.json()
    if err.get("code") == "email_duplicate":
        print("ℹ️  Draft already exists – fetching its ID")
        q = urllib.parse.quote_plus(subject)
        time.sleep(1)  # brief pause avoids immediate eventual‑consistency issue
        drafts = requests.get(
            f"{BTN_API}/emails?state=draft&search={q}", headers=headers, timeout=TIMEOUT
        )
        drafts.raise_for_status()
        try:
            email_id = drafts.json()["results"][0]["id"]
            print("✓ Re‑using draft:", email_id)
        except (IndexError, KeyError):
            bail("Duplicate reported but existing draft not found – aborting")
    else:
        bail(f"Draft upload failed → {err}")

# ---------------------------------------------------------------------------
# 2⃣  Send draft
# ---------------------------------------------------------------------------
print("⏳ Sending to subscribers…")

send_resp = requests.post(
    f"{BTN_API}/emails/{email_id}/send-draft",
    headers=headers,
    data=json.dumps({}),  # empty body → full subscriber list
    timeout=TIMEOUT,
)

if send_resp.ok:
    print("✅ Sent at", datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC"))
elif send_resp.status_code == 400 and send_resp.json().get("code") == "email_duplicate":
    print("ℹ️  Email already sent earlier – nothing to do")
    sys.exit(0)
else:
    bail(f"Send failed → {send_resp.status_code}: {send_resp.text}")